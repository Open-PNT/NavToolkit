#include <gtest/gtest.h>
#include <tensor_assert.hpp>

#include <navtk/filtering/containers/NavSolution.hpp>
#include <navtk/filtering/stateblocks/EarthModel.hpp>
#include <navtk/filtering/stateblocks/Pinson15NedBlock.hpp>
#include <navtk/filtering/utils.hpp>
#include <navtk/navutils/gravity.hpp>
#include <navtk/navutils/math.hpp>
#include <navtk/navutils/navigation.hpp>
#include <navtk/tensors.hpp>
#include <navtk/utils/conversions.hpp>

using navtk::cross;
using navtk::dot;
using navtk::Matrix;
using navtk::Matrix3;
using navtk::Vector;
using navtk::Vector3;
using navtk::filtering::calc_numerical_jacobian;
using navtk::filtering::EarthModel;
using navtk::filtering::NavSolution;
using navtk::navutils::skew;
using std::cos;
using std::sin;
using std::tan;

/*
 * Takes the raw components of Pinson aux data, corrects them with the error state estimates, and
 * returns the corrected aux data needed to propagate the state block. Note that the correction
 * uses the Titterton and Weston definition of errors (true = estimate - error), which is the
 * opposite of our typical assumption (additive errors). However, as long as the signs of the error
 * states are consistent the propagation model is the same, though this is generally not the case
 * outside of propagation (measurement updates/feedback).
 *
 * @param ns Uncorrected/raw NavSolution.
 * @param fned Raw(measured) specific force in the NED frame, m/s^2.
 * @param xx Pinson15Ned error state vector.
 *
 * @return PinsonAux created from ns and fned, which have been corrected by subtracting
 * the state estimates.
 */
std::pair<Pva, Imu> correct(NavSolution ns, Vector3 fned, Vector3 w_b_ib, Vector xx) {
	auto cor_lat = ns.pos[0] - navtk::navutils::north_to_delta_lat(xx[0], ns.pos[0], ns.pos[2]);
	auto cor_lon = ns.pos[1] - navtk::navutils::east_to_delta_lon(xx[1], ns.pos[0], ns.pos[2]);
	auto cor_alt = ns.pos[2] + xx[2];
	auto cor_vel = ns.vel - xt::view(xx, xt::range(3, 6));
	auto cor_cnb =
	    dot((navtk::eye(3) + skew(xt::view(xx, xt::range(6, 9)))), xt::transpose(ns.rot_mat));
	// Funny bit. Technically cor_fned ought to be calculated by using cor_cnb to rotate the bias
	// states into the navigation frame, but this brings in a sizable error state multiplier (tilts
	// * accel_bias) that isn't accounted for in the T+W derivation. To keep the tests passing for
	// now there are a few places that follow that use the uncorrected dcm when handling accel bias
	// rotations; they are all noted
	auto cor_fned = fned - dot(xt::transpose(ns.rot_mat), xt::view(xx, xt::range(9, 12)));

	auto cor_ns     = NavSolution(Vector3{cor_lat, cor_lon, cor_alt},
                              cor_vel,
                              xt::transpose(cor_cnb),
                              aspn_xtensor::TypeTimestamp((int64_t)0));
	auto w_b_ib_cor = w_b_ib - xt::view(xx, xt::range(12, 15));
	auto pva        = navtk::utils::to_positionvelocityattitude(cor_ns);
	auto f_and_r    = navtk::utils::to_imu(pva.get_time_of_validity(), cor_fned, w_b_ib_cor);
	return {pva, f_and_r};
}

/*
 * Generates the F matrix (Jacobian of the continuous time propagation function/differential
 * equations) from a Pinson15Ned StateBlock using the supplied aux data.
 *
 * @param aux AspnBaseVector to use as linearization point.
 *
 * @return 15x15 Jacobian of the continuous time propagation function.
 */
Matrix calc_pinson_f(Pva pva_aux, Imu f_and_r_aux) {
	auto mod = navtk::filtering::hg1700_model();
	auto p15 = navtk::filtering::Pinson15NedBlock("p15", mod);
	return p15.generate_f_pinson15(pva_aux, f_and_r_aux);
}

/*
 * Test case for evaluating correctness of various Pinson propagation elements, specifically the F
 * Jacobian Matrix (which is transcribed from a book) against other calculations of the same,
 * usually from numerical methods. Equation methods throughout file are from Titterton and Weston,
 * Strapdown Inertial Navigation Technology, 2nd ed unless otherwise noted.
 */
struct Pinson15NonlinearTests : public ::testing::Test {
	/* Pinson15 error state vector, subtractive error definition */
	Vector x15;
	/* Raw specific forces, NED frame, m/s^2 */
	Vector3 fned;
	/* Raw body rotation rates, in the body/ins frame, rad/s */
	Vector3 w_b_ib;
	/* Nominal/raw ins position, LLA, rad/rad/m */
	Vector3 pos;
	/* Nominal/raw ins velocity, NED frame, m/s */
	Vector3 vned;
	/* Nominal/raw ins roll, pitch, yaw, radians */
	Vector3 rpy;
	/* Nominal/raw ins body to nav DCM (from rpy) */
	Matrix3 cnb;
	/* Nominal/raw ins NavSolution, containing pos, vned, rpy, cnb */
	NavSolution ns;
	/* AspnBaseVector created by passing ns, fned and x15 through the 'correct' function to remove
	 * error.
	 */
	std::pair<Pva, Imu> aux;
	Pva cor_pva_aux;
	Imu cor_f_and_r_aux;
	/* The 15x15 F matrix generated by the Pinson15Ned StateBlock when linearized about cor_aux */
	Matrix jac15;


	Pinson15NonlinearTests()
	    : ::testing::Test(),
	      x15({1.0, 1.0, 1.0, 0.1, 0.1, 0.1, 1e-4, 1e-4, 1e-4, 1e-6, 1e-6, 1e-6, 1e-9, 1e-9, 1e-9}),
	      fned({1e-5, 2e-4, -9.79}),
	      w_b_ib({-2e-6, 4e-4, 1e-5}),
	      pos({0.7, -1.4, 123.0}),
	      vned({1.0, -0.5, 6.7}),
	      rpy({1.0, 2.0, 2.2}),
	      cnb(navtk::navutils::rpy_to_dcm(rpy)),
	      ns(NavSolution(pos, vned, xt::transpose(cnb), aspn_xtensor::TypeTimestamp((int64_t)0))),
	      aux(correct(ns, fned, w_b_ib, x15)),
	      cor_pva_aux(aux.first),
	      cor_f_and_r_aux(aux.second),
	      jac15(calc_pinson_f(cor_pva_aux, cor_f_and_r_aux)) {}
};

/*
 * PVA differential equations.
 *
 * @param ns PVA process to integrate.
 * @param fb Specific force input, in body frame m/s^2.
 * @param w_b_ib Body rotation rate input, in body frame rad/s.
 *
 * @return A NavSolution holding p_dot (NED frame), v_dot and cbn_dot (use of NavSolution container
 * is an abuse; result is not actually a valid NavSolution).
 */
NavSolution straight_prop(Pva pva, Vector3 fb, Vector3 w_b_ib) {
	Vector ned_dot = navtk::utils::extract_vel(pva);
	auto em        = EarthModel(navtk::utils::extract_pos(pva), ned_dot);
	Vector v_dot   = dot(navtk::navutils::quat_to_dcm(pva.get_quaternion()), fb) -
	               cross(2.0 * em.omega_ie_n + em.omega_en_n, ned_dot) + em.g_n;
	auto cnb        = navtk::navutils::quat_to_dcm(pva.get_quaternion());
	Matrix3 cnb_dot = dot(cnb, skew(w_b_ib)) - dot(skew(em.omega_in_n), cnb);

	return NavSolution(
	    ned_dot, v_dot, xt::transpose(cnb_dot), aspn_xtensor::TypeTimestamp((int64_t)0));
}

TEST_F(Pinson15NonlinearTests, pinson_delta_pva_prop_SLOW) {
	auto fx = [ns = ns, fned = fned, w_b_ib = w_b_ib](Vector xx) {
		auto plain_aux = correct(ns, fned, w_b_ib, navtk::zeros(15));
		auto cor_aux   = correct(ns, fned, w_b_ib, xx);

		auto fb             = dot(ns.rot_mat, fned);
		Vector plain_force  = plain_aux.second.get_meas_accel();
		Vector cor_force    = cor_aux.second.get_meas_accel();
		Vector plain_rate   = plain_aux.second.get_meas_gyro();
		Vector cor_rate     = cor_aux.second.get_meas_gyro();
		NavSolution ns_prop = straight_prop(
		    plain_aux.first,
		    dot(xt::transpose(navtk::navutils::quat_to_dcm(plain_aux.first.get_quaternion())),
		        plain_force),
		    plain_rate);
		auto fb_cor             = dot(ns.rot_mat, cor_force);
		NavSolution ns_prop_cor = straight_prop(
		    cor_aux.first,
		    dot(xt::transpose(navtk::navutils::quat_to_dcm(plain_aux.first.get_quaternion())),
		        cor_force),
		    cor_rate);

		Vector pos_dot_diff = ns_prop.pos - ns_prop_cor.pos;
		Vector vel_dot_diff = ns_prop.vel - ns_prop_cor.vel;

		auto em_est  = EarthModel(ns.pos, ns.vel);
		auto em_true = EarthModel(navtk::utils::extract_pos(cor_aux.first),
		                          navtk::utils::extract_vel(cor_aux.first));

		Vector delta_omega_n_in = em_est.omega_in_n - em_true.omega_in_n;
		auto cbn_cor = xt::transpose(navtk::navutils::quat_to_dcm(cor_aux.first.get_quaternion()));

		auto skew_diff =
		    dot(skew(xt::view(xx, xt::range(6, 9))), skew(em_true.omega_in_n)) -
		    dot(skew(em_true.omega_in_n), skew(xt::view(xx, xt::range(6, 9)))) +
		    skew(delta_omega_n_in) -
		    dot(dot(xt::transpose(cbn_cor), skew(xt::view(xx, xt::range(12, 15)))), cbn_cor);

		Vector tilts{skew_diff(2, 1), skew_diff(0, 2), skew_diff(1, 0)};

		auto mod          = navtk::filtering::hg1700_model();
		Vector accel_bias = -(fb - fb_cor) / mod.accel_bias_tau;
		Vector gyro_bias  = -(w_b_ib - cor_rate) / mod.gyro_bias_tau;
		Vector complete =
		    xt::concatenate(xt::xtuple(pos_dot_diff, vel_dot_diff, tilts, accel_bias, gyro_bias));
		return complete;
	};

	auto nj = calc_numerical_jacobian(fx, x15);
	// We're using a 1st order model, which isn't as accurate as a higher order model would be, so
	// need to user higher tolerances here.
	ASSERT_ALLCLOSE_EX(nj, jac15, 1e-9, 1e-3);
}
